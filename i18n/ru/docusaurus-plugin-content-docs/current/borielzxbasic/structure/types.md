# Типы данных

## Введение

Хотя Boriel ZX BASIC был изначально разработан для ZX Spectrum, это трехступенчатый _многоцелевой_ компилятор. Это означает, что не должно быть трудно взломать Boriel ZX BASIC SDK для компиляции для других целевых машин (например, Commodore 64) или современных машин (PC) или даже виртуальных машин, таких как Java или .NET. Перенос Boriel ZX BASIC на другие архитектуры с процессором Z80, такие как Amstrad или MSX, должен быть почти простым (только library.asm должен быть немного доработан для использования различных процедур ПЗУ).

Как выше было сказано, _типы данных_ были разработаны для платформы Z80. Поэтому, например, 64-битные целые числа не реализованы.

## Типы данных

_Тип данных_ описывает, как значение переменной хранится в памяти. Например, в классической версии Sinclair ZX Basic переменная **всегда** содержит число с плавающей запятой или строку. Но в большинстве случаев это пустая трата времени и памяти. Например, почему бы нам не использовать всего один байт для хранения значения, о котором мы знаем, что это всегда целое число от 0 до 10?

Теперь вы можете так сделать: Boriel ZX BASIC вводит много новых типов данных для экономии памят и достижение более высокой скорости выполнения кода.

Существует три вида типов: **целые**, **десятичные** и **строки**.

### Целые

Целые - это числовые типы данных для хранения целых значений.

Это могут быть _беззнаковые_ (их значения всегда 0 или больше нуля) или _знаковые_ (может принимать отрицательные значения).
Размер целых типов в Boriel ZX Basic может быть 8, 16 или 32 бита. Беззнаковые типы имеют префикс _U_.


| Название типа | Размер (в байтах) | Знаковый? | Диапазон значений | Описание |
|:-----------|:-----:|:--------:|:------:|:-------------|
| Byte | 1 | да | -128..127  | 8-битное знаковое целое |
| UByte| 1 | нет | 0..255  | 8-битное беззнаковое целое |
| Integer | 2 | да | -32768..32767 | 16-битное знаковое целое |
| UInteger | 2 | нет | 0..65535 | 16-битное беззнаковое целое |
| Long | 4 | да |  <small>−2 147 483 648 .. +2 147 483 647</small> | 32-битное знаковое целое |
| ULong | 4 | нет | <small>0 .. 4 294 967 295</small>| 32-битное беззнаковое целое |

### Десятичные типы

**Десятичные типы**, как и следовало ожидать, хранят дробные десятичные числа, то есть числа с плавающей или фиксированной запятой.
Их размеры 32 бита для типа `Fixed` и 40 битов для типа `Float`.

#### Тип Fixed

Это 32-битное десятичное число с фиксированной запятой. Первые 16 бит отвечают за целую часть, в то время как оставшиеся 16 бит хранят десятичную (дробную) часть.

Тут может храниться число от -32767.9999847 до 32767.9999847 с точностью `1 / 2^16` (примерно 0.000015). Десятичные числа с фиксированной запятой менее точные, чем числа типа `Float`, но зато они намного более быстрые и требуют меньше места в ОЗУ (на целый 1 байт). Также их диапазон значений намного меньше.

Они обычно используются при рисовании на экране, если числа `Float` слишком медленные, но в то же время требуются десятичные вычисления.

#### Тип Float

Это десятичные числа с плавающей запятой и они абсолютно **идентичны** тем, которые применяются в Sinclair ZX Basic.

Такой типа требует 5 байтов (1 байт для экспоненты, 4 байта для мантиссы). Прочтите руководство к ZX Spectrum или [тут](http://www.worldofspectrum.org/ZXBasicManual/zxmanchap24.html).

> Для хранения номера в компьютере мы используем пять байтов, как показано ниже:
>
> Запишите первые восемь битов мантиссы во второй байт (мы знаем, что первый бит равен 1), вторые восемь битов в третий байт, третьи восемь битов в четвертый байт и четвертые восемь битов в пятый байт;
> замените первый бит во втором байте, который, как мы знаем, равен 1, на знак: 0 - плюс, 1 - минус;
> запишите `экспоненту+128` в первый байт. Например, если наше число это `1 / 10`, тогда<br/>
> 1 / 10 = (4 / 5) * 2<sup>(-3)</sup>

### Строки

Строковые типы используются для хранения последовательностей символов.

Строки могут содержать до 65535 символов, они также могут динамически менять свой размер, поэтому, в отличие от других типов данных, их содержимое хранится в другой области памяти, называемой "[**куча**](memory_heap)" (heap).

В большинстве диалектов языка `Basic`, имена строковых переменных имеют суффикс **$** (также называемый _sigil_), но в Boriel ZX Basic данный суффикс не является обязательным и вы можете его опустить.

## Классы

В данный момент Boriel ZX Basic не является <abbr title="Объектно-ориентированное программирование">ООП</abbr> компилятором. Но существуют три главных _класса_. Считайте, что здесь _класс_ это разновидность _типа данных_. 

### Класс Var

Классом Var обладают все _скалярные_ переменные. Скалярные переменные - это те, которые могут хранить только одно значение
.
Почти все переменные скалярные:

```
REM Простая скалярная переменная: a
DIM a = 3
```

### Массивы

В отличие от скаляров, массивы могут хранить больше чем одно значение одновременно.

Вы можете получить доступ к каждому из этих значений внутри массива используя целый _индекс_:

```
REM Переменная - массив
DIM a(1 TO 10) AS UBYTE
LET a(3) = 5: REM берём элемент a(3) и сохраняем 5 внутри него
```

### Метки

В отличие от вышеперечисленных, [метки](labels) - это не переменные.

Они указывают на позиции в памяти. Номера строк также могут рассматриваться как метки, но они полностью опциональные:

```
10 REM тут '10' - это метка
 5 REM тут '5' - это ещё одна метка, но порядок цифр не имеет никакого значения
   REM Номера строк необязательны. Так что с этой строкой всё в порядке.
   ' Эта строка тоже комментарий. Можно использовать символ (') вместо REM

mylabel:
   REM в строке выше 'mylabel' это тоже метка. Если метка не числовая,
   REM то она должна заканчиваться двоеточием (:)

   GOTO mylabel: REM Переходим на строку 'mylabel'

   GO TO 5: REM Другой способ написать оператор GOTO. Переходим на строку 5
```

## Также смотрите

* [DIM](../commands/dim) (выражение)
* [Метки](labels)
