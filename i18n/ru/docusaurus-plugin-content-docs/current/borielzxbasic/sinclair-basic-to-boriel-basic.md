---
sidebar_position: 2
title: От Sinclair ZX Basic к Boriel ZX Basic
---

# От Sinclair ZX Basic к Boriel ZX Basic

В этой статье мы объясним ряд концепций Boriel ZX Basic, ориентированных на программистов, которые пришли из классического Sinclair ZX Basic, и которые хотят начать программировать на Boriel ZX Basic. И хотя концепты полезны для классического ZX Spectrum, мы больше сосредоточимся на ZX Spectrum Next.

Невозможно обобщить или объяснить все в простой статье, и это не тот путь, который можно пройти за 2 минуты, поэтому в этом тексте мы объясним общие концепции, не вдаваясь в излишние подробности или продвинутые вопросы.

Чтобы выполнить шаги, описанные в этой статье, лучше всего иметь готовую среду программирования NextBuild, о которой мы рассказывали в статье "Подготовка среды для программирования для Next с помощью Boriel ZX Basic и NextBuild".

Для тестирования примеров мы создадим папку "Test" внутри "C:\ZXNext\NextBuildv7\Sources". После создания этой папки мы можем создать, например, файл "Test1.bas" и запустить в нем тесты.

## Но что дает мне Boriel ZX Basic?

Это первый вопрос, который обычно задают себе программисты, услышав о Boriel ZX Basic (далее Boriel). И ответ не прост, не потому что сложно объяснить, что он дает, а потому что это длинный ответ:

1. **Он компилирует код**: Boriel - это компилятор, что означает, что Boriel "преобразует" наш BASIC-код в машинный код. В отличие от него Sinclair ZX BASIC является интерпретируемым языком, что означает, что каждый раз, когда команда должна быть выполнена, ПЗУ должно прочитать, декодировать и выполнить ее. В отличие от этого, скомпилированный код выполняется намного быстрее.
1. **Оптимизирует код**: после компиляции Boriel может оптимизировать наш код, чтобы он стал еще быстрее и занимал меньше памяти. Например, большинство математических операций выполняются быстрее, CIRCLE работает быстрее, PRINT летает, и так далее, и так далее. Другим важным аспектом является то, что код, который никогда не выполняется, исключается, что уменьшает объем используемой памяти.
1. **Включает в себя усовершенствования языка**: Boriel добавляет возможности современных языков, таких как C или Visual Basic, и даже позволяет использовать ассемблер и обеспечивает простое взаимодействие между ним и Boriel, например, облегчая доступ к переменным BASIC из ассемблера.
1. **Позволяет структурировать код**: Структурирование кода делает код более удобным для чтения, и в то же время его легче повторно использовать в других проектах.
1. **Уменьшает порог входа для ассемблера**: Многие из нас, или, по крайней мере, я, сталкивались с барьером скорости. Игры на BASIC были медленными, а ассемблер - очень сложным. Boriel позволяет нам постепенно и очень естественно интегрировать ассемблер в наши программы.
1. **Поддержка**: Telegram-канал "Boriel ZX Basic" или форум Boriel очень активны, и создатель компилятора "Boriel", Boriel, довольно часто зависает на этих каналах.

## Различия между Sinclair ZX Basic и Boriel ZX Basic

Boriel на 95% совместим с Sinclair ZX Basic. В следующем списке мы можем увидеть основные различия:

### Номера строк

В Boriel они необязательны, т.е. вам не нужно ставить номера строк, что является одной проблемой, поскольку вам не нужно беспокоиться о нумерации или ограничении в 9999 строк.

```
10 BORDER 0: PAPER 0: INK 6: CLS
20 FOR N=0 TO 20
30 PRINT N
40 NEXT N
```

Это записывается как:

```
BORDER 0: PAPER 0: INK 6: CLS
FOR N=0 TO 20
     PRINT N
NEXT N
```

Обратите внимание, что мы отделяем PRINT символом табуляции перед ним, что облегчает чтение кода.

### Метки

Именно этот механизм в Boriel позволяет нам устранить номера строк. Вместо "GO TO 1000" или "GO SUB 1000" можно использовать "GO TO MyLabel" или "GO SUB MyLabel", а вместо строки 1000 поставить "MyLabel:".

```
10 LET A=0
20 LET A=A+1
30 PRINT AT 0,0;A
40 IF A<100 THEN GOTO 20
50 PRINT "END"
```

Это можно записать так:

```
LET A=0
Loop:
	LET A=A+1
	PRINT AT 0,0;A
	IF A<100 THEN GOTO Loop
PRINT "END"
```

### Вычисляемые переходы

Boriel не разрешает переходы типа `GO TO 1000+variable` или `GO TO variable`. В этом случае необходимо немного изменить концепцию или использовать таблицы переходов с командой `ON GOTO` или `ON GOSUB`, например: `ON variable GOTO 1000,1100,1200` перейдет на строку 1000, если переменная равна 0, на 1100, если она равна 1, на 1200, если она равна 2, и не перейдет, если она имеет любое другое значение.

```
10 GOTO 1000+(variable*100)
```

Это придётся записать так:

```
ON variable GOTO 1000,1100,1200
```

### Основание массива

Хотя параметр `-sinclair` в Boriel изменяет это поведение, по умолчанию индексы массивов `DIM a(100)` в Boriel начинаются с 0, а в Sinclair ZX Basic - с 1. Это означает, что этот `DIM a(100)` в Boriel будет иметь 101 элемент (от 0 до 100), а в Sinclair ZX Basic - только 100 (от 1 до 100).

Старт с 0 также применяется к оператору "TO" в строковых операциях:

```
LET A$="12345"
PRINT A$(1 TO 4)
```

На Sinclair ZX Basic он выведет "1234", а на Boriel - "2345".

Это поведение можно изменить с помощью параметров "-sinclair", "-array-base" и "-string-base", но самым обычным является привычка использовать 0 в качестве базового элемента.

### Строковые переменные без $

Использование $ для ссылки на текстовую переменную больше не обязательно, т.е. мы можем использовать `a="Hello"` вместо `a$="Hello"`.

Это также означает, что A является той же переменной, что и A$.

### Команды по умолчанию

Если не указано иное, не все команды Sinclair ZX Basic доступны, если мы не используем модификатор "-sinclair", хотя это не проблема, далеко не проблема, как мы увидим позже. Некоторые из этих команд - INPUT, ATTR и SCREEN$.

## Усовершенствования Boriel ZX Basic

Boriel улучшает Sinclair ZX BASIC, расширяя и делая его более гибким, позволяя нам использовать современные методы, которые до сих пор были доступны только в других языках, таких как C.

### Новые типы переменных

Переменные в Sinclair ZX Basic могут быть только двух типов - числовые или текстовые.

Числовые переменные всегда имеют тип FLOAT и всегда занимают 5 байт. Все математические операции, независимо от того, насколько они просты, проходят через калькулятор с плавающей запятой, что сильно замедляет выполнение.

Boriel включает в себя 6 типов переменных для целых чисел, два типа для чисел с десятичными дробями и один для текстовых строк. Если вы не укажете тип переменной, Boriel попытается присвоить наиболее подходящую, но это немного опасно, поэтому рекомендуется всегда определять тип переменной.

В следующей таблице представлены типы числовых переменных:

| Тип | Размер (байт) | Диапазон | Описание |
|-----|---------------|----------|----------|
| Byte | 1 | -128..127 | Знаковое 8-битное целое число
| UByte | 1 | 0..255 | Беззнаковое 8-битное целое число
| Integer | 2 | -32768..32767 | Знаковое 16-битное число
| UInteger | 2 | 0..65535 | Беззнаковое 16-битное число
| Long | 4 | -2147483648..+2147483647 | Знаковое 32-битное число
| ULong | 4 | 0..4294967295 | Беззнаковое 32-битное число

Что касается десятичных дробей, то у нас есть следующие типы:

| Тип | Размер (байт) | Диапазон | Описание |
|-----|---------------|----------|----------|
| Fixed | 4 | -32767.9999847..32767.9999847 | 16 бит для целочисленной части и 16 бит для десятичной части
| Float | 5 | Теряет точность при работе с большим количеством десятичных дробей или с очень большими числами | Этот тип используется в Sinclair ZX Basic. 8 бит для экспоненты и 24 бита для мантиссы (данных).

Текстовые строки не имеют заданного размера и занимают 2 байта плюс содержимое текста. Эти дополнительные два байта содержат фактический размер текста. Текстовые переменные определяются с помощью ключа `string`.

Boriel позволяет нам определить тип переменных, которые мы хотим использовать, что позволяет нам ускорить операции, выполняемые с этой переменной. Мы можем определить переменные следующим образом:

```
DIM numberSmall AS BYTE
DIM numberSmallNoSign AS UBYTE
DIM numberInteger1, numberInteger2 AS UINTEGER
DIM str AS STRING
DIM arrayInteger(100) AS UINTEGER
DIM arrayBidimensional(10,5) AS UBYTE
```

Следует отметить, что значение, указываемое при объявлении массива, указывает на количество элементов +1, так как индексы начинаются с 0. Короче говоря, 100 определяет, что он имеет 101 элемент, от 0 до 100.

Рекомендуется использовать наименьший возможный тип переменной, но будьте осторожны, чтобы не превысить максимальное и минимальное значения.

### Подпрограммы

В Sinclair ZX Basic подпрограммы вызываются командой `GOSUB line`, а возврат из них осуществляется командой `RETURN`:

```
10 LET Y=10
20 LET X=5
30 LET A$="HELLO"
30 GOSUB 1000
...
1000 PRINT AT Y,X;A$
1010 RETURN
```

Подпрограммы имеют ряд недостатков, например, пример выводит текст, содержащийся в A$ в строке Y и столбце X, но у нас нет ссылки на необходимые переменные.

В Boriel мы можем реализовать это следующим образом:

```
Print(10,5, "Hello")
...
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	PRINT AT Y,X;TEXT
END SUB
```

Как видно из примера на Boriel, переменные, требуемые подпрограммой, легко понять. Кстати, эти переменные называются "параметрами", то есть они являются параметрами подпрограммы.

В некотором смысле, `SUB` позволяют нам создавать свои собственные команды.

Давайте рассмотрим некоторые варианты:

```
DIM Row, Column AS UBYTE
Row=10
Column=5
Print(Row,Column, "Hello")
...
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	PRINT AT Y,X;TEXT
END SUB
```

Здесь мы видим, что в качестве параметров можно использовать переменные.

Теперь давайте улучшим процедуру печати:

```
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	DIM N, COLOR AS UBYTE
    COLOR=0
	PRINT AT Y,X;"";
	FOR N=0 TO LEN(TEXT)-1
		PRINT INK COLOR;TEXT(N);
		COLOR=COLOR+1
	NEXT N
END SUB
```

В этом примере мы улучшили подпрограмму Print, которая теперь печатает текст в цветах, но самое интересное, что мы определили две переменные ("N" и "COLOR"). Эти переменные "живут" только внутри SUB, то есть, когда мы вызываем подпрограмму, создаются две новые переменные, а когда мы выходим из подпрограммы, они будут уничтожены.

Результатом является то, что мы можем иметь переменную с тем же именем вне SUB, например:

```
DIM N AS UBYTE
FOR N=0 TO 10
	Print(N,0, "HELLO "+STR(N))
NEXT N
...
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	DIM N, COLOR AS UBYTE
	COLOR=0
	PRINT AT Y,X;"";
	FOR N=0 TO LEN(TEXT)-1
    	PRINT INK COLOR;TEXT(N);
        COLOR=COLOR+1
	NEXT N
END SUB
```

Этот пример печатает текст "HELLO 0", "HELLO 1", "HELLO 2", вплоть до "HELLO 10", в разных строках. Но самое любопытное, что у нас есть первый цикл, который использует переменную "N" (которая является глобальной переменной), и другая переменная с тем же именем "N" внутри SUB (которая называется локальной переменной), но они разные и их значения не смешиваются.

### Функции

FUNCTION - это подпрограмма (SUB), которая возвращает значение. 

Рассмотрим пример:

```
PRINT Sum(10,3)
...
FUNCTION Sum(A AS INTEGER, B AS INTEGER) AS INTEGER
	DIM R AS INTEGER
	R=A+B
	RETURN R
END FUNCTION
```

В этом примере мы определяем функцию `Sum`, которая складывает два значения типа INTEGER и возвращает результат в виде INTEGER. Очевидно, что его можно и нужно упростить с помощью простого `RETURN A+B`, но таким образом мы видим, что тут "локальные" переменные тоже могут быть использованы.

